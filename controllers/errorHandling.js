var errorHandlingService = require('../services/errorHandling');
var assert = require('assert');
var net = require('net');

function errorHandlingController() {
    
    this.sumValues = function (val_1, val_2, res) {

        assert.equal(typeof(val_1), 'number', "value 1 must be a number");
        assert.equal(typeof(val_2), 'number', "value 2 must be a number");

        return new Promise((resolve, reject) => {
            resolve(errorHandlingService.sumValues(val_1, val_2, res));
        }).then(result => {
            res.json(result);
        }).catch(err => {
            res.status(500).json({error: true, number: err.errno, origin: {module: 'errorHandlingController', function: 'sumValues'}, data: {message: err.message}});
        })
    }

    this.connect = function (ip4addr, tcpPort, timeout, res) {

        assert.equal(typeof(ip4addr), 'string', "argument 'ip4addr' must be a string");
        assert.ok(net.isIPv4(ip4addr), "argument 'ip4addr' must be a valid IPv4 address");

        assert.equal(typeof(tcpPort), 'number', "argument 'tcpPort' must be a string");
        assert.ok(!isNaN(tcpPort) && tcpPort > 0 && tcpPort < 65536, "argument 'tcpPort' must be a positive integer between 1 and 65535");

        assert.equal(typeof (timeout), 'number', "argument 'timeout' must be a number");
        assert.ok(!isNaN(timeout) && timeout > 0, "argument 'timeout' must be a positive integer");

        return new Promise((resolve, reject) => {
            resolve(errorHandlingService.connect(ip4addr, tcpPort, timeout, res));
        }).then(result => {
            res.json(result);
        }).catch(err => {
            res.status(500).json({error: true, number: err.errno, origin: {module: 'errorHandlingController', function: 'connect'}, data: {message: err.message}});
        })
    }

    this.sumAndRest = function (val_1, val_2, val_3, res) {

        assert.equal(typeof(val_1), 'number', "value 1 must be a number");
        assert.equal(typeof(val_2), 'number', "value 2 must be a number");
        assert.equal(typeof(val_3), 'number', "value 3 must be a number");
        assert.ok(val_3 > 0, "value 3 must be a positive number");

        return new Promise((resolve, reject) => {
            resolve(errorHandlingService.sumAndRest(val_1, val_2, val_3, res));
        }).then(result => {
            res.json(result);
        }).catch(err => {
            res.status(500).json({error: true, number: err.errno, origin: {module: 'errorHandlingController', function: 'sumAndRest'}, data: {message: err.message}});
        })
    }
}

module.exports = new errorHandlingController();


//var customErrorHandler = require('../error-handler-02');

/*// ERROR HANDLING PRACTICE
    this.deleteAuthor = function (id, res) {
        try {
            //throw ("I've fired an error!") // Creates a simple string
            //throw new Error("Something goes wrong!"); // Uses the Error class
            throw new customErrorHandler("Something goes wrong!", "authorController.deleteAuthor"); // Uses the custom error object
        } catch (error) {
            //console.log(error);
            //console.log(error.name);
            //console.log(error.message);
            //console.log(error.where);
            //console.log(error.stack);
            //console.log("It's generated by my custom error handler? "+(error instanceof customErrorHandler));
            if (error instanceof customErrorHandler){
                console.log("The error has been generated by custom error handler");
                console.log("At: "+error.where);
                console.log(error.stack);
            }
            else {
                console.log('Something fired a no handled error');
                throw error;
            }
        } finally { // With finally statement the code will be executed in spite of what happen in try or catch statement
            authorService.deleteAuthor(id, res);
        }
    }

    process.on("uncaughtException", function (error) {
        console.log("The exception was caught!")
    })*/